import streamlit as st
import pandas as pd
import plotly.express as px

import allocation

plotly_theme = 'plotly_dark'

ny_zone_dict = {'WEST':'A', 
                'GENESE':'B',
                'CENTRL':'C',
                'NORTH':'D',
                'MHK VL':'E',
                'CAPITL':'F',
                'HUD VL':'G',
                'MILLWD':'H',
                'DUNWOD':'I',
                'N.Y.C.':'J',
                'LONGIL':'K'
                }

RGE_load_class_dict = {101: 'Residential',
					   201: 'Small Commercial',
					   301: 'Gen Service - 100kw',
					   302: 'Gen Service - 100kw High Voltage',
					   401: 'Residential TOU',
					   701: 'Gen Service - 12kw',
					   801: 'SC8 - Secondary',
					   802: 'SC8 - Transmission Secondary',
					   803: 'SC8 - Primary',
					   804: 'SC8 - SubTrans: Industrial',
					   805: 'SC8 - SubTrans: Commercial',
					   901: 'TimeOfUse - Small Demand',
					   902: 'TimeOfUse - Small Demand High Voltage',
					   601: 'Area Lighting',
					   602: 'Street Lighting'
					   }

st.set_page_config(layout="wide")
st.title("Allocating zone loads to busses")


# Load profiles
SDH_profiles_df = pd.read_csv('data/RGE_profile_data.csv')
SDH_profiles_df['Load Class Name'] = SDH_profiles_df['load_class'].map(RGE_load_class_dict)

st.header('Load profiles')
st.markdown('This data demonstrates load profiles that describe the proportion of total load distributed to different \
	         load classes for each season x day x hour. This data is provided by Rochester Gas and Electic.')

profile_season = st.selectbox('Season', 
								options = SDH_profiles_df.Season.unique())
profile_day = st.selectbox('Day', 
							 options = SDH_profiles_df.DayType.unique())

current_SDH_profile = SDH_profiles_df[(SDH_profiles_df['Season']==profile_season) & (SDH_profiles_df['DayType']==profile_day)]

profile_fig = px.area(current_SDH_profile, x="hour", y='p_total_load', color='Load Class Name')
profile_fig.update_layout(height=600, width=1200)
st.plotly_chart(profile_fig, use_container_width=True, sharing="streamlit")



# prep zonal load data
zonal_load_df = pd.read_csv('data/zonal_load_data.csv')
zonal_load_df['Eastern Date Hour'] = pd.to_datetime(zonal_load_df['Eastern Date Hour'])

st.dataframe(zonal_load_df)

st.header('Zone Loads')
st.markdown('This is zone-specific load data for New York state broken down by zone, date, and hour')

zone_date = st.date_input('Date of interest',
						  value = min(zonal_load_df['Eastern Date Hour']),
						  min_value = min(zonal_load_df['Eastern Date Hour']),
						  max_value = max(zonal_load_df['Eastern Date Hour']))

current_zone_data = zonal_load_df[zonal_load_df['Eastern Date Hour'].isin(pd.date_range(zone_date, periods=24, freq="H"))]

zone_load_fig = px.line(current_zone_data,
	                    x = 'Eastern Date Hour',
	                    y = 'DAM Forecast Load',
	                    color = 'Zone Name')

zone_load_fig.update_layout(height=600, width=1200)
st.plotly_chart(zone_load_fig, use_container_width=True, sharing="streamlit")


st.header('Custom allocation')

with st.expander("See full methodological explaination"):
	
	st.markdown("""
			The attribution of load to each bus in a zone is generated by creating a sequence of random values that represent the proportion of total zonal load for a load class that is distributed to each bus. Across all of the load classes, these values create a 'signature' for each of the busses that simulate heterogeneity between the busses based their proportional consumption of each load class. Note that the proportions do not sum to one for each bus, but across a load class. Consider the following hypothetical example for a system with two busses and 3 load classes - the algorithm would generate something like the following table:  
			""")

	col1, col2, col3 = st.columns([4,3,4])

	with col1:
		st.write("")

	with col2:
		st.markdown("""
			|Load Class|Bus|Proportion|
			|--------|-----|------|
			|101|1|0.8|
			|101|2|0.2|
			|201|1|0.5|
			|201|2|0.5|
			|301|1|0.1|
			|301|2|0.9|

		""")

	with col3:
		st.write("")

	st.text("")
	st.text("")

	st.markdown("""  

			The proportions can be generated using either a normal or uniform distribution, and can include weights (any numerical value) to represent the relative magnitude of the load attributed to the bus.  

			The resulting flow of load distribution for a given season x day x hour would look like the following:  

		""")

	st.text("")
	st.text("")

	col1, col2, col3 = st.columns([1,3,1])

	with col1:
		st.write("")

	with col2:
		st.image('bus_load_attribution_drawio.png', use_column_width='auto')

	with col3:
		st.write("")


# file upload widget

st.markdown("""To generate your own allocation of loads to busses, you need to supply a .csv file with the follwing information:

	""")

example_bus_data = pd.read_csv('data/example_bus_data.csv')[['bus_id', 'zone', 'weight']]

col1, col2, col3 = st.columns([4,2,4])
with col1:
	st.write("")

with col2:
	st.dataframe(example_bus_data)

with col3:
	st.write("")

st.text("")

st.markdown("""
	where 
	- `bus_id` contains an value representing a unique id of each bus
	- `zone` associates the bus with one of the 15 zones present in New York
	- `weight` represents the relative magnitude of the load at each bus  

	Note that the distribution of loads is sensitive to the 'weight' parameter - the load will be randomly assigned across busses if the weight is constant, but large differences in weights between busses can result in large differences in resulting loads distributed to those busses.

	""")

st.header('load custom bus data')

uploaded_file = st.file_uploader('load class distribution data', type='.csv')

# bus_df = None

if uploaded_file is not None:
	bus_df = pd.read_csv(uploaded_file)
	if bus_df is not None:
		col1, col2, col3 = st.columns([4,4,4])
		with col2:
			st.dataframe(bus_df)
		diagnostic_bus_weight_hist = px.histogram(bus_df,
												  title='distribution of bus weights',
												  x='weight',
												  nbins=30,
												  log_y=True,
												  opacity=0.5,
												  template=plotly_theme)
		diagnostic_bus_weight_hist.update_layout(height=600, width=1600)
		st.plotly_chart(diagnostic_bus_weight_hist, use_container_width=True)


st.header('Generate bus profiles using data from above')

col1, col2, col3, col4 = st.columns([1,1,1,1])

with col2:
	random_type = st.radio('Random method', options=['Normal', 'Uniform'])

with col3:
	if random_type == 'Normal':
		random_uniform=False
		random_mean = st.number_input('mean', value=100)
		random_sd = st.number_input('standard_deviation', value=1)
	else:
		random_uniform=True

allocation_ran=False
col1, col2, col3 = st.columns([6,2,6])
with col2:
	if st.button('Generate Bus Profiles'):
		allocation_ran=True


if allocation_ran:
	if bus_df is None:
		st.error('There is no bus data uploaded!')
	else:
		bus_profile_df = allocation.generate_bus_profiles(bus_df, SDH_profiles_df, random_uniform)
		
		# load_hist = px.histogram(bus_profile_df, x='class_bus_allocation', color='load_class')
		load_hist = px.histogram(bus_profile_df, 
	                    x='class_bus_allocation', 
	                    facet_col='load_class', 
	                    labels={'class_bus_allocation':'% allocated'},
	                    facet_col_wrap=3, 
	                    log_y=True,
	                    nbins=30,
	                    opacity=0.5,
	                    template=plotly_theme)
		load_hist.update_layout(height=1200, width=1600)
		st.plotly_chart(load_hist, use_container_width=True)

		bus_profile_df.to_csv('bus_allocations.csv')
		with open('bus_allocations.csv', 'rb') as f:
				st.download_button('Download bus profiles', f, file_name='bus_allocations.csv')  # Defaults to 'application/octet-stream'



	st.dataframe(bus_profile_df)

			# day_type = zone_date.dt.day_name
			# season_type = zone_date.dt.month_name
			# result = allocation.allocate_load(sdhz_df, bus_df, SDH_profiles_df, output_filename)
			

